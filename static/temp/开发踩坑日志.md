# 开发踩坑日志


## 前端
### vite打包vue3，本地无法直接访问index.html
file协议跨域，解决方法
1. 开启http服务
2. 配置`@vitejs/plugin-legacy`
	```js
    import { fileURLToPath, URL } from 'node:url'
	
    import { defineConfig } from 'vite'
    import vue from '@vitejs/plugin-vue'  
    import legacy from "@vitejs/plugin-legacy";  //添加此处
    // https://vitejs.dev/config/
    export default defineConfig({
      plugins: [
	
        vue(),
        legacy({ //添加此处
          targets: ["ie>=11"],
          additionalLegacyPolyfills: ["regenerator-runtime/runtime"],
        }),
        // ...
      ],
      base: "./",
      publicPath:"./",
      resolve: {
        alias: {
          '@': fileURLToPath(new URL('./src', import.meta.url))
        }
      },
    })
	



## 后端与服务器

### SSE长连接问题

此问题出现在开发一个使用SSE的模块中，技术框架如下：
- Flask（Faab）
- Vue3
- MySQL
- Nginx
- uWSGI

问题复现：在本地进行测试时正常（Flask Debug模式），部署到服务器上时出现异常，使用域名连接SSE，仅当uWSGI重启时候才会收到全部的SSE信息。

*debug流程*

1. 调试前端，console输出。失败

2. 调试后端print输出。失败

3. 更换域名为ip地址。成功

4. 更新Nginx配置，设置**proxy_buffering:off**;。成功

总结：
> 原因是 Nginx 缓冲了响应，导致前端无法收到消息。
> 需要设置 Nginx 不对 SSE 响应进行缓冲，直接透传给客户端。

```conf
# SSE 通常不需要特别的 location 配置，可以根据需要进行设置
location /stream {
    # 设置 Nginx 不对 SSE 响应进行缓冲，直接透传给客户端
    proxy_buffering off;

    # 设置代理读取服务器响应的超时时间
    proxy_read_timeout 24h;

    # 设置客户端连接的超时时间
    proxy_connect_timeout 1h;

    # 设置 HTTP 版本，SSE 需要 HTTP/1.1
    proxy_http_version 1.1;

    # 保持连接活性，不发送连接关闭的信号
    proxy_set_header Connection '';

    # 配置代理传递的头部，确保 Host 头部正确传递
    proxy_set_header Host $host;

    # 配置代理的后端服务器地址
    proxy_pass http://backend_upstream;

    # 设置代理的响应头部，保持传输编码为 chunked
    proxy_set_header X-Accel-Buffering no;

    # 设置跨域资源共享 (CORS)，如果你的客户端和服务器不在同一个域上
    add_header 'Access-Control-Allow-Origin' '*' always;
    add_header 'Access-Control-Allow-Credentials' 'true' always;
    add_header 'Access-Control-Allow-Methods' 'GET, OPTIONS' always;
    add_header 'Access-Control-Allow-Headers' 'Origin,Authorization,Accept,X-Requested-With' always;
    if ($request_method = 'OPTIONS') {
    # 如果请求方法为 OPTIONS，则返回 204 (无内容)
    add_header 'Access-Control-Allow-Origin' '*';
    add_header 'Access-Control-Allow-Methods' 'GET, OPTIONS';
    add_header 'Access-Control-Allow-Headers' 'Origin,Authorization,Accept,X-Requested-With';
    add_header 'Access-Control-Max-Age' 1728000;
    add_header 'Content-Type' 'text/plain charset=UTF-8';
    add_header 'Content-Length' 0;
    return 204;
    }
}
```

### docker内部署Nginx

#### 出现400或502错误
使用docker部署Nginx做反向代理时，不能直接使用127.0.0.1，要使用宿主机IP
在安装Docker的时候，会在宿主机安装一个虚拟网关 docker0，查询docker0的IP地址
`ip addr show docker0`，也就是`172.17.0.1`

docker访问宿主机hostname也有一个选择：`host.docker.internal`



配置nginx.conf

```conf
# 注意 upstream 没有http, 这里的ip就是上面对于docker来说宿主机的ip
 upstream music {
        server 172.17.0.1:8080;
    }
    server {
        listen 80;
        # 如果由域名配置为域名即可，如果没有域名配置为本机ip地址
        # 如果想要外部访问就配置为本机的外网ip
        server_name xx.xx.xx.xx;
        location / {
            proxy_set_header Host $host:$server_port;
            proxy_set_header X-Real-Ip $remote_addr;
            proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
            # 这里就是上面的upstream
            proxy_pass http://music;
        }

    }
```


### Docker部署MySQL8.0无法开启远程访问

通过修改mysql表使远程访问：https://blog.csdn.net/qq_34885184/article/details/107564110

1. 登录MySQL
    ```sql
    mysql -uroot -p
    ```
2. 更改加密方式（注意，在原始的user表中root对应的host是localhost；如果有修改过，则下面的代码要做相应的改变）
    ```sql
    ALTER USER 'root'@'localhost' IDENTIFIED BY 'password' PASSWORD EXPIRE NEVER;
    ```
3. 更改密码：该例子中 123为新密码，也可以是你原来登录的密码
    ```sql
       ALTER USER 'root'@'localhost' IDENTIFIED WITH mysql_native_password BY '123';
    ```
4. 刷新
    ```sql
    FLUSH PRIVILEGES;
    ```
5. 进入mysql数据库（MySQL自带的一个数据库）
    ```sql
    use mysql;
    ```
6. 查看user表
    ```sql
    select host,user from user;
    ```
6. 改表

    ```sql
    update user set host = '%' where user = 'root';
    ```
6. 查看改表结果
    ```sql
    select host,user from user;
    ```
    用户root的host设为%，表示可以在任何的主机上通过root访问MySQL数据库。


可能需要以下步骤修改bind-address:
```
注意：配置8.0版本参考：我这里通过这种方式没有实现所有IP都能访问；我是通过直接修改配置文件才实现的，MySQL8.0版本把配置文件 my.cnf 拆分成mysql.cnf 和mysqld.cnf，我们需要修改的是mysqld.cnf文件：

sudo vim /etc/mysql/mysql.conf.d/mysqld.cnf

修改 bind-address，保存后重启MySQL即可。

bind-address = 0.0.0.0

重启MySQL重新加载一下配置：

sudo systemctl restart mysql

```





